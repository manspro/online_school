"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const stream_1 = require("stream");
const asset_enum_1 = require("../../../common/asset/enums/asset.enum");
class MetadataTransform extends stream_1.Transform {
    constructor(className, asset) {
        super({ encoding: 'utf-8' });
        this.className = className;
        this.asset = asset;
        this.MODULE_METADATA_REGEX = /@Module\(([\s\S]*?)\)/;
    }
    _transform(chunk, encoding, done) {
        const metadata = this.update(JSON.parse(this.MODULE_METADATA_REGEX.exec(chunk)[1].replace(/([a-zA-Z]+)/g, '"$1"')));
        const output = chunk.toString().replace(this.MODULE_METADATA_REGEX, `@Module(${JSON.stringify(metadata, null, 2).replace(/"/g, '')})`);
        this.push(output);
        done();
    }
    update(metadata) {
        switch (this.asset) {
            case asset_enum_1.AssetEnum.COMPONENT:
                metadata = this.updateComponents(metadata);
                break;
            case asset_enum_1.AssetEnum.CONTROLLER:
                metadata = this.updateControllers(metadata);
                break;
        }
        return metadata;
    }
    updateComponents(metadata) {
        if (metadata.hasOwnProperty('components')) {
            metadata['components'].push(this.className);
        }
        else {
            metadata.components = [this.className];
        }
        return metadata;
    }
    updateControllers(metadata) {
        if (metadata.hasOwnProperty('controllers')) {
            metadata['controllers'].push(this.className);
        }
        else {
            metadata.controllers = [this.className];
        }
        return metadata;
    }
}
exports.MetadataTransform = MetadataTransform;
