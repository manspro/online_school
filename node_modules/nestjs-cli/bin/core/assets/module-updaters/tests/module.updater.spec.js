"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const module_updater_1 = require("../module.updater");
const sinon = require("sinon");
const logger_service_1 = require("../../../logger/logger.service");
const test_utils_1 = require("../../streams/tests/test.utils");
const module_finder_1 = require("../../module-finders/module.finder");
const fs = require("fs");
const file_system_utils_1 = require("../../../utils/file-system.utils");
const chai_1 = require("chai");
const asset_enum_1 = require("../../../../common/asset/enums/asset.enum");
describe('ModuleUpdaterImpl', () => {
    let sandbox;
    beforeEach(() => sandbox = sinon.sandbox.create());
    afterEach(() => sandbox.restore());
    beforeEach(() => sandbox.stub(logger_service_1.LoggerService, 'getLogger').callsFake(() => {
        return {
            info: () => { }
        };
    }));
    let reader;
    let intermediateWriter;
    let intermediateReader;
    let writer;
    beforeEach(() => {
        const content = 'import {Module} from \'@nestjs/common\';\n' +
            '\n' +
            '@Module({})\n' +
            'export class AssetModule {}\n';
        reader = new test_utils_1.BufferedReadable(Buffer.from(content));
        intermediateWriter = new test_utils_1.BufferedWritable();
        intermediateReader = new test_utils_1.BufferedReadable(Buffer.from(content));
        writer = new test_utils_1.BufferedWritable();
    });
    let findFromStub;
    let createReadStreamStub;
    let createWriteStream;
    let rmStub;
    beforeEach(() => {
        findFromStub = sandbox.stub(module_finder_1.ModuleFinderImpl.prototype, 'findFrom');
        createReadStreamStub = sandbox.stub(fs, 'createReadStream').callsFake(filename => {
            return /.lock/.test(filename) ? intermediateReader : reader;
        });
        createWriteStream = sandbox.stub(fs, 'createWriteStream').callsFake(filename => {
            return /.lock/.test(filename) ? intermediateWriter : writer;
        });
        rmStub = sandbox.stub(file_system_utils_1.FileSystemUtils, 'rm').callsFake(() => Promise.resolve());
    });
    describe('#update()', () => {
        let updater;
        beforeEach(() => updater = new module_updater_1.ModuleUpdaterImpl());
        context('update from component asset', () => {
            const filename = 'path/to/asset/asset.service.ts';
            const relativeModuleFilename = './asset.service.ts';
            const className = 'AssetService';
            const moduleFilename = 'path/to/asset/asset.module.ts';
            beforeEach(() => findFromStub.callsFake(() => Promise.resolve(moduleFilename)));
            it('should use the module finder to retrieve the nearest module path', () => {
                return updater.update(filename, className, asset_enum_1.AssetEnum.COMPONENT)
                    .then(() => {
                    sinon.assert.calledWith(findFromStub, filename);
                });
            });
            it('should read the module filename', () => {
                return updater.update(filename, className, asset_enum_1.AssetEnum.COMPONENT)
                    .then(() => {
                    sinon.assert.calledWith(createReadStreamStub, moduleFilename);
                });
            });
            it('should update the module filename content', () => {
                return updater.update(filename, className, asset_enum_1.AssetEnum.COMPONENT)
                    .then(() => {
                    chai_1.expect(intermediateWriter.getBuffer().toString()).to.be.equal('import {Module} from \'@nestjs/common\';\n' +
                        `import {${className}} from ${relativeModuleFilename};\n` +
                        '\n' +
                        '@Module({\n' +
                        '  components: [\n' +
                        `    ${className}\n` +
                        '  ]\n' +
                        '})\n' +
                        'export class AssetModule {}\n');
                });
            });
            it('should write the updated file content in a intermediate lock file', () => {
                return updater.update(filename, className, asset_enum_1.AssetEnum.COMPONENT)
                    .then(() => {
                    sinon.assert.calledWith(createWriteStream, `${moduleFilename}.lock`);
                });
            });
            it('should read the updated intermediate module file when update write is end', () => {
                return updater.update(filename, className, asset_enum_1.AssetEnum.COMPONENT)
                    .then(() => {
                    sinon.assert.calledWith(createReadStreamStub, `${moduleFilename}.lock`);
                });
            });
            it('should write the updated module filename', () => {
                return updater.update(filename, className, asset_enum_1.AssetEnum.COMPONENT)
                    .then(() => {
                    sinon.assert.calledWith(createWriteStream, moduleFilename);
                });
            });
            it('should delete the lock file when write is ended', () => {
                return updater.update(filename, className, asset_enum_1.AssetEnum.COMPONENT)
                    .then(() => {
                    sinon.assert.calledOnce(rmStub);
                });
            });
        });
        context('update from controller asset', () => {
            const filename = 'path/to/asset/asset.controller.ts';
            const relativeModuleFilename = './asset.controller.ts';
            const className = 'AssetService';
            const moduleFilename = 'path/to/asset/asset.module.ts';
            beforeEach(() => findFromStub.callsFake(() => Promise.resolve(moduleFilename)));
            it('should use the module finder to retrieve the nearest module path', () => {
                return updater.update(filename, className, asset_enum_1.AssetEnum.CONTROLLER)
                    .then(() => {
                    sinon.assert.calledWith(findFromStub, filename);
                });
            });
            it('should read the module filename', () => {
                return updater.update(filename, className, asset_enum_1.AssetEnum.CONTROLLER)
                    .then(() => {
                    sinon.assert.calledWith(createReadStreamStub, moduleFilename);
                });
            });
            it('should update the module filename content', () => {
                return updater.update(filename, className, asset_enum_1.AssetEnum.CONTROLLER)
                    .then(() => {
                    chai_1.expect(intermediateWriter.getBuffer().toString()).to.be.equal('import {Module} from \'@nestjs/common\';\n' +
                        `import {${className}} from ${relativeModuleFilename};\n` +
                        '\n' +
                        '@Module({\n' +
                        '  controllers: [\n' +
                        `    ${className}\n` +
                        '  ]\n' +
                        '})\n' +
                        'export class AssetModule {}\n');
                });
            });
            it('should write the updated file content in a intermediate lock file', () => {
                return updater.update(filename, className, asset_enum_1.AssetEnum.CONTROLLER)
                    .then(() => {
                    sinon.assert.calledWith(createWriteStream, `${moduleFilename}.lock`);
                });
            });
            it('should read the updated intermediate module file when update write is end', () => {
                return updater.update(filename, className, asset_enum_1.AssetEnum.CONTROLLER)
                    .then(() => {
                    sinon.assert.calledWith(createReadStreamStub, `${moduleFilename}.lock`);
                });
            });
            it('should write the updated module filename', () => {
                return updater.update(filename, className, asset_enum_1.AssetEnum.CONTROLLER)
                    .then(() => {
                    sinon.assert.calledWith(createWriteStream, moduleFilename);
                });
            });
            it('should delete the lock file when write is ended', () => {
                return updater.update(filename, className, asset_enum_1.AssetEnum.CONTROLLER)
                    .then(() => {
                    sinon.assert.calledOnce(rmStub);
                });
            });
        });
    });
});
