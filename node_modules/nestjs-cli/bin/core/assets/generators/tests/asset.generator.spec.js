"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const sinon = require("sinon");
const file_system_utils_1 = require("../../../utils/file-system.utils");
const asset_builder_1 = require("../../builders/asset.builder");
const template_builder_1 = require("../../builders/template.builder");
const fs = require("fs");
const stream_1 = require("stream");
const path = require("path");
const asset_generator_1 = require("../asset.generator");
const logger_service_1 = require("../../../logger/logger.service");
describe('AssetGenerator', () => {
    let sandbox;
    beforeEach(() => sandbox = sinon.sandbox.create());
    afterEach(() => sandbox.restore());
    let mkdirStub;
    let createReadStreamStub;
    let createWriteStreamStub;
    let pipeSpy;
    let getLoggerStub;
    beforeEach(() => {
        mkdirStub = sandbox.stub(file_system_utils_1.FileSystemUtils, 'mkdir').callsFake(() => Promise.resolve());
        createReadStreamStub = sandbox.stub(fs, 'createReadStream').callsFake(() => {
            const reader = new stream_1.PassThrough();
            reader.end();
            return reader;
        });
        createWriteStreamStub = sandbox.stub(fs, 'createWriteStream').callsFake(() => new stream_1.PassThrough());
        pipeSpy = sandbox.spy(stream_1.PassThrough.prototype, 'pipe');
        getLoggerStub = sandbox.stub(logger_service_1.LoggerService, 'getLogger').callsFake(() => {
            return {
                info: () => { }
            };
        });
    });
    let generator;
    beforeEach(() => generator = new asset_generator_1.AssetGenerator());
    describe('#generate()', () => {
        const asset = new asset_builder_1.AssetBuilder()
            .addFilename('asset-filename')
            .addClassName('className')
            .addTemplate(new template_builder_1.TemplateBuilder()
            .addFilename('template-filename')
            .addReplacer({})
            .build())
            .build();
        it('should generate the asset folder structure', () => {
            return generator.generate(asset)
                .then(() => {
                sinon.assert.calledWith(mkdirStub, path.dirname(path.relative(process.cwd(), asset.filename)));
            });
        });
        it('should open a read stream from the asset template filename', () => {
            return generator.generate(asset)
                .then(() => {
                sinon.assert.calledWith(createReadStreamStub, asset.template.filename);
            });
        });
        it('should open a write stream to the asset filename', () => {
            return generator.generate(asset)
                .then(() => {
                sinon.assert.calledWith(createWriteStreamStub, asset.filename);
            });
        });
        it('should pipe the read stream to the write stream by applying a reply transform', () => {
            return generator.generate(asset)
                .then(() => {
                sinon.assert.called(pipeSpy);
            });
        });
        it('should reject when an error occurred in the pipeline', () => {
            createReadStreamStub.callsFake(() => {
                const reader = new stream_1.PassThrough();
                reader.emit('error', 'error message');
                return reader;
            });
            return generator.generate(asset)
                .then(() => {
                throw new Error('should not be here');
            })
                .catch(error => {
                chai_1.expect(error.message).to.be.equal('Unhandled "error" event. (error message)');
            });
        });
    });
});
