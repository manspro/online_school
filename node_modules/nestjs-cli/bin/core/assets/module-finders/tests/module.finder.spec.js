"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const sinon = require("sinon");
const chai_1 = require("chai");
const module_finder_1 = require("../module.finder");
const file_system_utils_1 = require("../../../utils/file-system.utils");
describe('ModuleFinder', () => {
    let sandbox;
    beforeEach(() => sandbox = sinon.sandbox.create());
    afterEach(() => sandbox.restore());
    let finder;
    beforeEach(() => finder = new module_finder_1.ModuleFinderImpl());
    describe('#findFrom()', () => {
        let readdirStub;
        beforeEach(() => readdirStub = sandbox.stub(file_system_utils_1.FileSystemUtils, 'readdir'));
        it('should return the first module absolute path from the origin path with module at the same level', () => {
            readdirStub.callsFake(() => Promise.resolve(['file.component.ts', 'file.module.ts', 'file.controller.ts']));
            return finder.findFrom('path/to/file.controller.ts')
                .then(filename => {
                sinon.assert.calledWith(readdirStub, 'path/to');
                chai_1.expect(filename).to.be.equal('path/to/file.module.ts');
            });
        });
        it('should return the first module absolute path from the origin path with module at a parent level', () => {
            readdirStub.callsFake((dirname) => {
                if (dirname === 'path/to')
                    return Promise.resolve(['file.component.ts', 'file.controller.ts']);
                else {
                    return Promise.resolve(['file.module.ts']);
                }
            });
            return finder.findFrom('path/to/file.controller.ts')
                .then(filename => {
                sinon.assert.calledWith(readdirStub, 'path/to');
                sinon.assert.calledWith(readdirStub, 'path');
                chai_1.expect(filename).to.be.equal('path/file.module.ts');
            });
        });
    });
});
